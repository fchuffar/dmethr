---
title: "Step 1: CpG status of region surrounding TSS"
author: "Florence Pittion, Florent Chuffart"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
---



```{r, echo=FALSE, eval=TRUE, label="loading libraries"}
knitr::opts_chunk$set(collapse=TRUE, comment = "#>", fig.width=9, fig.height=6, eval=TRUE, echo=FALSE, results="hide")
```

```{r}
source("common.R")
if (!exists("step")) step = 100
if (!exists("nb_rnd_feat")) nb_rnd_feat = 2000
if (!exists("ud_str")) ud_str = 2500
up_str = dwn_str = ud_str
prefix = "tss"
prefix = paste0(prefix, "_", up_str, "_", dwn_str, "_", step, "_", nb_rnd_feat, "")
```

```{r globals variables}
hg38_chrom_sizes  = read.table("~/projects/genes/hg38.chrom.sizes", stringsAsFactors=FALSE)
rownames(hg38_chrom_sizes) = hg38_chrom_sizes[,1]
```

# Purpose

The main goal of this study is to define CpG status of genome region around TSS by computing CpG density from genome sequence.

It happends in 2 steps : 
  
  - extract genome sequence around TSS
  - count the number of CG in the sequence


# Features

```{r}
feats_orig = readRDS("~/projects/genes/bed_grch38_epimeddb.rds")[,1:6]
feats = feats_orig
head(feats)
dim(feats)
```

```{r filtering anbd downsampling}
# Filtering according to...
# feats = feats[
#   # feats$score>5 &
#   feats$len<5000
#   ,]
# plot_feat_den(feats$len, feats$score, xlim, ylim)

# Downsampling
if (nb_rnd_feat > 0) {
  dim(feats)
  set.seed(1)
  feats = feats[sort(sample(1:nrow(feats), min(nrow(feats), nb_rnd_feat))),]
  dim(feats)  
  # plot_feat_den(feats$len, feats$score, xlim, ylim, xlab="length", ylab="#probes")
}
```


# CpG enrichment of features

```{r Extract DNA sequences of TSS +/- ud_str bp}
seq_filename = paste0("seq_", prefix, ".rds")
if (!file.exists(seq_filename)) {
  seq = get_seq_from_bed(feats, up_str, dwn_str, hg38_chrom_sizes)
  saveRDS(seq, seq_filename)
}
seq = readRDS(seq_filename)
length(seq)
```

```{r Slice DNA sequences and count CpG density}
mat = get_matbin_from_seq(seq, up_str, dwn_str, step)
head(mat)
dim(mat)

binmax = apply(mat, 1, function(l) {
  maxIndex = which(l%in%max(l, na.rm=TRUE))[1]
})
head(binmax)
feats$binmax = NA
feats[names(binmax),]$binmax = binmax


cpg_density = apply(mat, 1, mean, na.rm=TRUE)
feats$cpg_density = NA
feats[names(cpg_density),]$cpg_density = cpg_density


head(feats)
```



CpG density ( nb. of CpG / length of sequence) is computed in sequence of TSS +/-`r ud_str/1000`kb sliced into `r step` bins.

TSS of 1000 random feats is represented there. It shows a CpG enrichment aoroud TSS.

```{r label="heatmap for 1000 rnd feats", fig.height=9}
set.seed(1)
data = mat[order(binmax[rownames(mat)]),]
data = data[sort(sample(1:nrow(data), min(nrow(data), 1000))), ]
colors=c("black",  "red")
cols = colorRampPalette(colors)(20)
rownames(data) = NULL
gplots::heatmap.2(data, Rowv=NULL,  Colv=NULL,  dendrogram="none", trace="none", col=cols, main=paste0("CpG enrichment (feats +/-", ud_str/1000, "kb, 1000 rnd feats)"), xaxt="n", mar=c(8,5))
```




















## Centered features


```{r centered, fig.height=9}
if (feature_pretreatment == "cen") {
  # stop("EFN")
  feats$start_orig = feats[,2] 
  feats$end_orig = feats[,3]  
  feats$strand_orig = feats[,6]  
  feats$tss = ifelse(feats[,6]=="+", feats[,2], feats[,3])
  # feats[,2] = feats$tss - (feats[,6]=="-")+0
  feats[,2] = feats$tss - ud_str + step*feats$binmax + floor(step/2)
  feats[,3] = feats[,2] + 1
  head(feats)

  seq_filename = paste0("seq_centered_", prefix, ".rds")
  if (!file.exists(seq_filename)) {
    seq = get_seq_from_bed(feats, up_str, dwn_str, hg38_chrom_sizes)
    saveRDS(seq, seq_filename)
  }
  seq = readRDS(seq_filename)
  length(seq)
  # ```
  # ```{r mat_cpg_binmax}
  mat = get_matbin_from_seq(seq, up_str, dwn_str, step)
  head(mat)
  dim(mat)
  binmax = apply(mat, 1, function(l) {
    maxIndex = which(l==max(l))[1]
  })
  head(binmax)
  feats$binmax = NA
  feats[names(binmax),]$binmax = binmax
  head(feats)
  # ```
  # ```{r label="heatmap for 1000 rnd feats", fig.height=9}
  set.seed(1)
  data = mat[order(binmax[rownames(mat)]),]
  data = data[sort(sample(1:nrow(data), min(nrow(data), 1000))), ]
  colors=c("black",  "red")
  cols = colorRampPalette(colors)(20)
  rownames(data) = NULL
  gplots::heatmap.2(data, Rowv=NULL,  Colv=NULL,  dendrogram="none", trace="none", col=cols, main=paste0("CpG enrichment (feats +/-", ud_str/1000, "kb, 1000 rnd feats)"), xaxt="n", mar=c(8,5))  
} 
```





















# CpG density

CpG density distribution is represented there. 

It shows that MOST OF TSS are CpG enriched compared to random sequence.  

It also shows that NOT ALL TSS are are CpG enriched.

```{r label="CpG density distribution"}
nb_cpg_rnd_filename = paste0("nb_cpg_rnd_TSS_", up_str, "_", dwn_str, ".rds")
if (!file.exists(nb_cpg_rnd_filename)) {
  idx = sample(1:22, 5000, replace=TRUE)
  set.seed(1)
  pos = sapply(hg38_chrom_sizes[idx,2], function(e) round(runif(1, 15000, e-15000)))
  rnd_feat = data.frame(hg38_chrom_sizes[idx,1], pos, stringsAsFactors=FALSE)
  nb_cpg_rnd = epimedtools::monitored_apply(mod=10, rnd_feat, 1, function(feat) {
    chr = feat[[1]]
    tss = as.numeric(feat[[2]])
    bef = up_str
    aft = dwn_str
    beg = max(1,tss - bef)
    end = min(hg38_chrom_sizes[chr,2], tss + aft)
    str = as.character(BSgenome::getSeq(BSgenome.Hsapiens.UCSC.hg38::Hsapiens, chr, beg, end))
    # stringr::str_count(str, "CG") / nchar(str)
    lnn = nchar(gsub("N", "", str))
    # denom = l - lnn
    if (lnn==0) {
      return(NA)
    } else {
      return(stringr::str_count(str, "CG") / lnn)
    }
  })
  saveRDS(nb_cpg_rnd, nb_cpg_rnd_filename)
}
nb_cpg_rnd = readRDS(nb_cpg_rnd_filename)

nb_cpg_tss = apply(mat, 1, mean, na.rm=TRUE)

layout(matrix(1:2,1), respect=TRUE)
plot(density(nb_cpg_tss),ylim=c(0,100), main="CpG enrichment distribution", xlab="CpG density", ylab="", yaxt="n")
lines(density(nb_cpg_rnd, na.rm=TRUE), col=2)
legend("topright", c(paste0("tss +/-", ud_str/1000, "kb"), paste0("rnd pos +/-", ud_str/1000, "kb")), col=1:2, lty=1)
plot(density(log10(nb_cpg_tss)), main="CpG enrichment distribution", xlab="log10(CpG density)", ylab="", yaxt="n")
lines(density(log10(nb_cpg_rnd), na.rm=TRUE), col=2)
legend("topright", c(paste0("tss +/-", ud_str/1000, "kb"), paste0("rnd pos +/-", ud_str/1000, "kb")), col=1:2, lty=1)
```



# Clustering 


Then we clustering TSS according to there sliced CpG density

PCA on TSS +/-`r ud_str/1000`kb sliced into `r step`b bins is performed.

Component 1 discriminates CpG rich and poor TSS.

```{r clustering}
mat = mat[!apply(is.na(mat), 1, any),] 
pca = prcomp(mat, scale=FALSE)
v = pca$sdev * pca$sdev
p = v / sum(v) * 100


layout(matrix(1:2,1), respect=TRUE)
barplot(p)
i = 1
plot(density(pca$x[,i]), main=paste0("PC", i, "(", signif(p[i], 3), "%)"))

#set.seed(3)
#km = kmeans(pca$x[,1], 2)
#thresh = mean(km$centers)
#abline(v=thresh)

#plot(pca$x[,1], pca$x[,2], col=km$cluster)
#abline(v=thresh)

#idx1 = names(km$cluster)[km$cluster==1]
#idx2 = names(km$cluster)[km$cluster==2]

library(mclust)
em = Mclust(pca$x[,1], G=2)
plot(em, what = "density")
summary(em)
plot(pca$x[,1], pca$x[,2], col=em$classification)


idx1 = names(em$classification)[em$classification==1]
idx2 = names(em$classification)[em$classification==2]

feats$cpg_status  = NA
if (mean(mat[idx1,]) < mean(mat[idx2,])) {
  feats[idx1,]$cpg_status = "poor"
  feats[idx2,]$cpg_status = "rich"  
} else {
  feats[idx1,]$cpg_status = "rich"
  feats[idx2,]$cpg_status = "poor"
}



idx_rich = rownames(feats)[feats$cpg_status%in%"rich"]
idx_poor = rownames(feats)[feats$cpg_status%in%"poor"]

plot(apply(mat[idx_poor,], 2, mean), type="l", ylim=c(0, .13), col=1, main="CpG enrichment", xaxt="n")
lines(apply(mat[idx_rich,], 2, mean), col=2)
axis(1, at=c(0, ncol(mat)/2, ncol(mat)), label=c(paste0("TSS -", ud_str/1000, "kb"), "TSS", paste0("TSS +", ud_str/1000, "kb")))
legend("topright", legend=c(paste0("rich (", length(idx_rich), ")"), paste0("poor (", length(idx_poor), ")")), col=1:2, lty=1)

feats[rownames(mat),]$cpg_density = apply(mat, 1, mean)
# WriteXLS::WriteXLS(feats, "feats_cpg_status.xls")
```








```{r}
i=1
for (j in 2:3) {
  layout(1, respect=TRUE)
  plot(pca$x[,i], pca$x[,j], xlab=paste0("PC", i, "(", signif(p[i], 3), "%)"), ylab=paste0("PC", j, "(", signif(p[j], 3), "%)"), pch=16, col=cols)

  layout(matrix(1:9, 3, byrow=FALSE), respect=TRUE)

  threshs_i = quantile(pca$x[,i], c(1/3, 2/3))
  threshs_j = quantile(pca$x[,j], c(1/3, 2/3))

  idx_i = idx_j = list()
  idx_i[[1]] = rownames(pca$x)[pca$x[,i] <  threshs_i[1]]
  idx_i[[2]] = rownames(pca$x)[pca$x[,i] >= threshs_i[1] & pca$x[,i] < threshs_i[2]]
  idx_i[[3]] = rownames(pca$x)[pca$x[,i] >= threshs_i[2] ]
  idx_j[[1]] = rownames(pca$x)[pca$x[,j] <  threshs_j[1]]
  idx_j[[2]] = rownames(pca$x)[pca$x[,j] >= threshs_j[1] & pca$x[,j] < threshs_j[2]]
  idx_j[[3]] = rownames(pca$x)[pca$x[,j] >= threshs_j[2] ]

  for (it in 1:3) {
    for (jt in 1:3) {
      idx = intersect(idx_i[[it]], idx_j[[jt]])
      plot(apply(mat[idx,], 2, mean),  col=1, type="l", ylim=c(0, .13), main=paste0("PC", i, "Q", it, " PC", j, "Q" , jt), xaxt="n", ylab="CpG density")
      axis(1, at=c(0, ncol(mat)/2, ncol(mat)), label=c(paste0("TSS -", ud_str/1000, "kb"), "TSS", paste0("TSS +", ud_str/1000, "kb")))
    }
  }  
}
```



